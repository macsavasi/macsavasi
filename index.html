<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Stream Battle Royale</title>
    <link href="https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Montserrat:wght@800&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0; overflow: hidden; background-color: #050505;
            font-family: 'Montserrat', sans-serif; touch-action: none; user-select: none;
        }

        /* Dinamik Arka Plan */
        #bg-canvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: -2; background: #080808;
        }

        #gameCanvas { 
            display: block; width: 100vw; height: 100vh; z-index: 1;
        }

        /* UI Katmanları */
        .ui-layer {
            position: absolute; width: 100%; pointer-events: none; z-index: 10;
            display: flex; justify-content: center;
        }

        .top-bar {
            top: 20px;
            flex-direction: column; align-items: center;
        }

        .title-text {
            font-family: 'Black Ops One', cursive; 
            font-size: 3rem; 
            background: linear-gradient(to bottom, #fff, #aaa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.8));
            letter-spacing: 3px;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .sub-text {
            font-size: 1.2rem; color: #ff0055; font-weight: 800;
            text-shadow: 0 0 10px #ff0055; letter-spacing: 2px;
            animation: blink 2s infinite;
        }

        /* Kalan Sayacı (Arka Plan Dev Yazı) */
        #survivor-count-bg {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Black Ops One'; font-size: 25vw;
            color: rgba(255, 255, 255, 0.03);
            pointer-events: none; z-index: -1;
            transition: all 0.2s;
        }

        /* Kazanan Ekranı */
        #winnerOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.85); z-index: 100;
            backdrop-filter: blur(5px);
        }

        #w-card {
            background: linear-gradient(135deg, #1a1a1a, #000);
            border: 4px solid #FFD700;
            padding: 40px; border-radius: 20px;
            text-align: center;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.5), inset 0 0 20px rgba(255, 215, 0, 0.2);
            transform: scale(0.8); animation: popIn 0.5s forwards cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        #w-flag {
            width: 150px; height: 150px; border-radius: 50%;
            border: 6px solid #fff; box-shadow: 0 0 30px #FFD700;
            object-fit: cover; margin-bottom: 20px;
        }

        #w-title { font-family: 'Black Ops One'; font-size: 4rem; color: #FFD700; margin: 0; line-height: 1; text-shadow: 0 5px 10px rgba(0,0,0,0.5); }
        #w-name { font-size: 2.5rem; color: #fff; text-transform: uppercase; font-weight: 900; margin-top: 10px; }
        #timer { margin-top: 20px; font-size: 1.2rem; color: #00ffff; font-family: monospace; }

        @keyframes blink { 0%, 100% {opacity: 1;} 50% {opacity: 0.5;} }
        @keyframes popIn { to { transform: scale(1); } }
    </style>
</head>
<body>

    <div id="survivor-count-bg">00</div>

    <div class="ui-layer top-bar">
        <div class="title-text">FLAG BATTLE</div>
        <div class="sub-text">SURVIVAL ARENA</div>
    </div>

    <div id="winnerOverlay">
        <div id="w-card">
            <div id="w-title">VICTORY</div>
            <br>
            <img id="w-flag" src="" alt="">
            <div id="w-name">COUNTRY</div>
            <div id="timer">RESTARTING...</div>
        </div>
    </div>

    <canvas id="bg-canvas"></canvas>
    <canvas id="gameCanvas"></canvas>

<script>
    // --- GÖRSEL AYARLAR ---
    const CONFIG = {
        ballSize: 16,
        arenaColor: '#00f3ff', // Neon Cyan
        failColor: '#ff0055', // Neon Red
        bgColor: '#080808',
        trailLength: 10,       // Topların arkasındaki iz uzunluğu
        particleCount: 15,     // Çarpışma partikül sayısı
        shakeIntensity: 8      // Düşme anındaki titreme
    };

    const canvas = document.getElementById('gameCanvas');
    const bgCanvas = document.getElementById('bg-canvas');
    const ctx = canvas.getContext('2d');
    const bgCtx = bgCanvas.getContext('2d');
    
    const winnerOverlay = document.getElementById('winnerOverlay');
    const wFlag = document.getElementById('w-flag');
    const wName = document.getElementById('w-name');
    const timerText = document.getElementById('timer');
    const survivorCountBg = document.getElementById('survivor-count-bg');

    // --- SES SİSTEMİ (Web Audio API) ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx = new AudioContext();

    function unlockAudio() {
        if (audioCtx.state === 'suspended') audioCtx.resume();
    }
    window.addEventListener('click', unlockAudio, {once:true});
    window.addEventListener('touchstart', unlockAudio, {once:true});

    function playSound(type) {
        if (audioCtx.state === 'suspended') return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        const now = audioCtx.currentTime;

        if (type === 'hit') {
            // Tok çarpışma sesi
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(120, now);
            osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.start(now);
            osc.stop(now + 0.1);
        } else if (type === 'die') {
            // Düşme/Patlama sesi (8-bit style)
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(400, now);
            osc.frequency.exponentialRampToValueAtTime(50, now + 0.4);
            gain.gain.setValueAtTime(0.4, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
            osc.start(now);
            osc.stop(now + 0.4);
        }
    }

    // --- SETUP ---
    let WIDTH, HEIGHT, CX, CY, ARENA_RADIUS;
    function resize() {
        WIDTH = window.innerWidth;
        HEIGHT = window.innerHeight;
        canvas.width = WIDTH; canvas.height = HEIGHT;
        bgCanvas.width = WIDTH; bgCanvas.height = HEIGHT;
        CX = WIDTH / 2;
        CY = HEIGHT * 0.45; // Arenayı biraz yukarı al
        ARENA_RADIUS = (Math.min(WIDTH, HEIGHT) / 2) * 0.75;
    }
    resize();
    window.addEventListener('resize', resize);

    // --- GRID BACKGROUND EFFECT ---
    let gridOffset = 0;
    function drawBackground() {
        bgCtx.fillStyle = CONFIG.bgColor;
        bgCtx.fillRect(0, 0, WIDTH, HEIGHT);
        
        bgCtx.strokeStyle = 'rgba(0, 255, 255, 0.08)';
        bgCtx.lineWidth = 1;
        bgCtx.beginPath();
        
        // Hareketli Grid
        const gridSize = 60;
        gridOffset = (gridOffset + 0.5) % gridSize;
        
        // Dikey çizgiler
        for(let x = 0; x <= WIDTH; x += gridSize) {
            bgCtx.moveTo(x, 0); bgCtx.lineTo(x, HEIGHT);
        }
        // Yatay çizgiler (perspektif hissi için aşağı doğru kayıyor)
        for(let y = gridOffset; y <= HEIGHT; y += gridSize) {
            bgCtx.moveTo(0, y); bgCtx.lineTo(WIDTH, y);
        }
        bgCtx.stroke();

        // Hafif Vinyet
        const grad = bgCtx.createRadialGradient(CX, CY, ARENA_RADIUS, CX, CY, WIDTH);
        grad.addColorStop(0, 'rgba(0,0,0,0)');
        grad.addColorStop(1, 'rgba(0,0,0,0.8)');
        bgCtx.fillStyle = grad;
        bgCtx.fillRect(0,0,WIDTH,HEIGHT);
    }

    // --- GAME LOGIC ---
    const COUNTRIES = [
        {c:'tr',n:'Turkey'}, {c:'us',n:'USA'}, {c:'de',n:'Germany'}, {c:'br',n:'Brazil'}, {c:'fr',n:'France'},
        {c:'gb',n:'UK'}, {c:'it',n:'Italy'}, {c:'ru',n:'Russia'}, {c:'cn',n:'China'}, {c:'jp',n:'Japan'},
        {c:'kr',n:'S. Korea'}, {c:'in',n:'India'}, {c:'ca',n:'Canada'}, {c:'au',n:'Australia'}, {c:'es',n:'Spain'},
        {c:'mx',n:'Mexico'}, {c:'id',n:'Indonesia'}, {c:'sa',n:'Saudi Arabia'}, {c:'ar',n:'Argentina'},
        {c:'ng',n:'Nigeria'}, {c:'eg',n:'Egypt'}, {c:'pk',n:'Pakistan'}, {c:'vn',n:'Vietnam'},
        {c:'ph',n:'Philippines'}, {c:'th',n:'Thailand'}, {c:'ir',n:'Iran'}, {c:'nl',n:'Netherlands'}, {c:'pl',n:'Poland'},
        {c:'ua',n:'Ukraine'}, {c:'co',n:'Colombia'}, {c:'se',n:'Sweden'}, {c:'az',n:'Azerbaijan'}, {c:'pt',n:'Portugal'},
        {c:'gr',n:'Greece'}, {c:'be',n:'Belgium'}, {c:'ch',n:'Switzerland'}, {c:'at',n:'Austria'}, {c:'hu',n:'Hungary'},
        {c:'no',n:'Norway'}, {c:'dk',n:'Denmark'}, {c:'fi',n:'Finland'}, {c:'ie',n:'Ireland'}, {c:'nz',n:'New Zealand'},
        {c:'sg',n:'Singapore'}, {c:'my',n:'Malaysia'}, {c:'cl',n:'Chile'}, {c:'pe',n:'Peru'}, {c:'ve',n:'Venezuela'},
        {c:'ec',n:'Ecuador'}, {c:'ma',n:'Morocco'}, {c:'dz',n:'Algeria'}, {c:'kz',n:'Kazakhstan'}, {c:'il',n:'Israel'},
        {c:'qa',n:'Qatar'}, {c:'ae',n:'UAE'}, {c:'hr',n:'Croatia'}, {c:'rs',n:'Serbia'}, {c:'ba',n:'Bosnia'}
    ];

    let balls = [];
    let particles = [];
    let arenaRotation = 0;
    let screenShake = 0;
    let gameRunning = true;
    let animationId;
    
    // Sabitler
    const ROTATION_SPEED = 0.03;
    const GAP_SIZE = Math.PI / 4; // Boşluk boyutu
    const FRICTION = 0.99;
    const GRAVITY = 0.35;

    class Particle {
        constructor(x, y, color, speed) {
            this.x = x; this.y = y;
            this.color = color;
            this.angle = Math.random() * Math.PI * 2;
            this.speed = Math.random() * speed + 2;
            this.vx = Math.cos(this.angle) * this.speed;
            this.vy = Math.sin(this.angle) * this.speed;
            this.life = 1.0;
            this.decay = Math.random() * 0.03 + 0.01;
            this.size = Math.random() * 4 + 2;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += 0.1; // Gravity on particles
            this.life -= this.decay;
        }
        draw() {
            ctx.globalAlpha = Math.max(0, this.life);
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }

    class Ball {
        constructor(data) {
            this.code = data.c;
            this.name = data.n;
            this.r = CONFIG.ballSize;
            
            // Başlangıç konumu (Ortada rastgele)
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * (ARENA_RADIUS * 0.5);
            this.x = CX + Math.cos(angle) * dist;
            this.y = CY + Math.sin(angle) * dist;

            // Rastgele hız
            this.vx = (Math.random() - 0.5) * 15;
            this.vy = (Math.random() - 0.5) * 15;

            // Görsel
            this.img = new Image();
            this.img.src = `https://flagcdn.com/w80/${this.code}.png`;
            
            this.state = 'ALIVE'; 
            this.trail = []; // Kuyruk için
        }

        update() {
            // Trail Logic
            if (this.state === 'ALIVE' || this.state === 'FALLING') {
                this.trail.push({x: this.x, y: this.y});
                if(this.trail.length > CONFIG.trailLength) this.trail.shift();
            }

            if (this.state === 'ALIVE') {
                // Hareket ve Sürtünme
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= FRICTION;
                this.vy *= FRICTION;

                // Minimum hareket garantisi (Oyunun durmaması için)
                const speed = Math.hypot(this.vx, this.vy);
                if(speed < 1.5) { this.vx *= 1.1; this.vy *= 1.1; }
                if(speed > 18) { this.vx *= 0.9; this.vy *= 0.9; }

                // Arena Duvar Kontrolü
                const dist = Math.hypot(this.x - CX, this.y - CY);
                if (dist + this.r >= ARENA_RADIUS) {
                    let angle = Math.atan2(this.y - CY, this.x - CX);
                    if (angle < 0) angle += Math.PI * 2;

                    // Boşluk kontrolü
                    let gapStart = (arenaRotation % (Math.PI * 2));
                    let gapEnd = (gapStart + GAP_SIZE) % (Math.PI * 2);
                    
                    let inGap = false;
                    if (gapStart < gapEnd) {
                        if (angle >= gapStart && angle <= gapEnd) inGap = true;
                    } else {
                        if (angle >= gapStart || angle <= gapEnd) inGap = true;
                    }

                    if (inGap) {
                        // Düşüş Başladı
                        this.state = 'FALLING';
                        playSound('die');
                        screenShake = CONFIG.shakeIntensity;
                        createExplosion(this.x, this.y, '#fff', 10);
                    } else {
                        // Sektirme
                        const overlap = dist + this.r - ARENA_RADIUS;
                        const nx = (this.x - CX) / dist;
                        const ny = (this.y - CY) / dist;
                        
                        this.x -= nx * overlap;
                        this.y -= ny * overlap;

                        // Yansıma Vektörü
                        const dot = this.vx * nx + this.vy * ny;
                        this.vx = (this.vx - 2 * dot * nx) * 1.05; // Biraz enerji kazanır
                        this.vy = (this.vy - 2 * dot * ny) * 1.05;

                        playSound('hit');
                        createExplosion(this.x, this.y, CONFIG.arenaColor, 3);
                    }
                }
            } 
            else if (this.state === 'FALLING') {
                this.vy += GRAVITY;
                this.x += this.vx;
                this.y += this.vy;

                // Ekran dışına çıkınca tamamen silinsin mi?
                if (this.y > HEIGHT + 100) {
                    this.state = 'DEAD';
                }
            }
        }

        draw() {
            if(this.state === 'DEAD') return;

            // Trail Çizimi
            if(this.trail.length > 1) {
                ctx.beginPath();
                ctx.moveTo(this.trail[0].x, this.trail[0].y);
                for(let i=1; i<this.trail.length; i++){
                    ctx.lineTo(this.trail[i].x, this.trail[i].y);
                }
                ctx.strokeStyle = this.state === 'ALIVE' ? 'rgba(255,255,255,0.3)' : 'rgba(255,0,85,0.5)';
                ctx.lineWidth = this.r;
                ctx.lineCap = 'round';
                ctx.stroke();
            }

            // Top Çizimi
            ctx.save();
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
            ctx.closePath();
            
            // Gölge Efekti
            ctx.shadowColor = this.state === 'ALIVE' ? 'rgba(0,0,0,0.5)' : CONFIG.failColor;
            ctx.shadowBlur = this.state === 'ALIVE' ? 0 : 20;
            
            ctx.clip();
            ctx.drawImage(this.img, this.x - this.r, this.y - this.r, this.r*2, this.r*2);
            ctx.restore();

            // Çerçeve
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
            ctx.strokeStyle = this.state === 'ALIVE' ? '#fff' : CONFIG.failColor;
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }

    function createExplosion(x, y, color, count) {
        for(let i=0; i<count; i++) {
            particles.push(new Particle(x, y, color, 5));
        }
    }

    function resolveCollisions() {
        for (let i = 0; i < balls.length; i++) {
            for (let j = i + 1; j < balls.length; j++) {
                let b1 = balls[i];
                let b2 = balls[j];
                
                if (b1.state !== 'ALIVE' || b2.state !== 'ALIVE') continue;

                let dx = b2.x - b1.x;
                let dy = b2.y - b1.y;
                let dist = Math.hypot(dx, dy);
                let minDist = b1.r + b2.r;

                if (dist < minDist) {
                    let angle = Math.atan2(dy, dx);
                    let tx = b1.x + Math.cos(angle) * minDist;
                    let ty = b1.y + Math.sin(angle) * minDist;

                    let ax = (tx - b2.x) * 0.5; // Spring force
                    let ay = (ty - b2.y) * 0.5;

                    b1.x -= ax;
                    b1.y -= ay;
                    b2.x += ax;
                    b2.y += ay;

                    // Hız değişimi (basit elastik çarpışma simülasyonu)
                    let vCollision = {x: b2.vx - b1.vx, y: b2.vy - b1.vy};
                    let vRelNormal = vCollision.x * (dx/dist) + vCollision.y * (dy/dist);
                    
                    if(vRelNormal < 0) { // Sadece birbirlerine doğru geliyorlarsa
                        let impulse = vRelNormal * 1.1; // Biraz ekstra enerji (kaos için)
                        b1.vx += impulse * (dx/dist);
                        b1.vy += impulse * (dy/dist);
                        b2.vx -= impulse * (dx/dist);
                        b2.vy -= impulse * (dy/dist);
                        
                        // Yüksek hızda çarpışmada efekt
                        if(Math.abs(impulse) > 5) {
                            createExplosion((b1.x+b2.x)/2, (b1.y+b2.y)/2, '#ffff00', 3);
                            playSound('hit');
                        }
                    }
                }
            }
        }
    }

    function drawArena() {
        arenaRotation += ROTATION_SPEED;
        
        ctx.save();
        // Neon Glow Efekti
        ctx.shadowBlur = 30;
        ctx.shadowColor = CONFIG.arenaColor;
        
        ctx.strokeStyle = CONFIG.arenaColor;
        ctx.lineWidth = 15;
        ctx.lineCap = 'round';

        ctx.beginPath();
        // Boşluklu Çember
        ctx.arc(CX, CY, ARENA_RADIUS, arenaRotation + GAP_SIZE, arenaRotation + Math.PI*2);
        ctx.stroke();

        // Boşluk Kısmı (Tehlike Göstergesi - Kırmızı/Silik)
        ctx.shadowColor = CONFIG.failColor;
        ctx.shadowBlur = 15;
        ctx.strokeStyle = 'rgba(255, 0, 85, 0.3)';
        ctx.beginPath();
        ctx.arc(CX, CY, ARENA_RADIUS, arenaRotation, arenaRotation + GAP_SIZE);
        ctx.stroke();
        
        ctx.restore();
    }

    function animate() {
        if (!gameRunning) return;

        // Arka planı temizle
        drawBackground();
        ctx.clearRect(0, 0, WIDTH, HEIGHT);

        // Screen Shake
        ctx.save();
        if (screenShake > 0) {
            let dx = (Math.random() - 0.5) * screenShake;
            let dy = (Math.random() - 0.5) * screenShake;
            ctx.translate(dx, dy);
            screenShake *= 0.9;
            if(screenShake < 0.5) screenShake = 0;
        }

        drawArena();

        let aliveBalls = balls.filter(b => b.state === 'ALIVE');
        let survivor = aliveBalls.length === 1 ? aliveBalls[0] : null;

        // Sayacı güncelle
        survivorCountBg.innerText = aliveBalls.length;
        // Sayı azaldıkça kırmızılaşsın
        if(aliveBalls.length < 5) survivorCountBg.style.color = 'rgba(255, 0, 85, 0.15)';
        else survivorCountBg.style.color = 'rgba(255, 255, 255, 0.05)';

        // Topları Çiz & Güncelle
        balls.forEach(ball => {
            ball.update();
            ball.draw();
        });

        resolveCollisions();

        // Partikülleri Çiz
        for(let i = particles.length-1; i>=0; i--) {
            particles[i].update();
            particles[i].draw();
            if(particles[i].life <= 0) particles.splice(i, 1);
        }

        ctx.restore();

        // Oyun Bitiş Kontrolü
        if (aliveBalls.length <= 1 && survivor) {
            endGame(survivor);
        } else if (aliveBalls.length === 0) {
            resetGame(); // Kimse kalmazsa (nadir durum)
        } else {
            animationId = requestAnimationFrame(animate);
        }
    }

    function endGame(winner) {
        gameRunning = false;
        cancelAnimationFrame(animationId);
        
        // Kazanan Efekti
        createExplosion(WIDTH/2, HEIGHT/2, '#FFD700', 100);
        playSound('die');

        // UI Güncelleme
        wFlag.src = winner.img.src;
        wName.innerText = winner.name;
        winnerOverlay.style.display = 'flex';
        
        let count = 5;
        timerText.innerText = `NEXT BATTLE IN ${count}...`;
        
        let interval = setInterval(() => {
            count--;
            timerText.innerText = `NEXT BATTLE IN ${count}...`;
            if (count <= 0) {
                clearInterval(interval);
                resetGame();
            }
        }, 1000);
    }

    function resetGame() {
        winnerOverlay.style.display = 'none';
        balls = [];
        particles = [];
        
        // Topları karıştır ve ekle
        let shuffled = [...COUNTRIES].sort(() => Math.random() - 0.5);
        // İstersen burada sayıyı sınırlayabilirsin: shuffled.slice(0, 30) gibi
        shuffled.forEach(c => balls.push(new Ball(c)));
        
        gameRunning = true;
        animate();
    }

    window.onload = function() {
        unlockAudio();
        resetGame();
    };

</script>
</body>
</html>
